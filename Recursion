Recursion

In your own words, what is recursion?
Why is it necessary to have a base case?

Answer:
    Recursion is when a function calls on itself until the base case. The base case is necessary because, like loops, there needs to be a point at which the recursion stops. If there was no base case the function could go on calling it's self forever. 




Graphs

What is a graph?
How is a graph different from a tree?
Give an example of something that would be good to model with a graph.

Answer:
    A graph is a data structure that containes nodes and edges. Graphs can be directed or undirected and can also be unconnected. 
    Graphs have cycles which trees cannot have cycles.
    Markov chains



Performance of Different Data Structures

Fill in the missing spots in the chart with the correct runtimes. Do this by reasoning through how the data structures work, NOT by looking up the solution. Add-R means add to the right/end/top and Add-L means add to the left/beginning/bottom. There are X’s in the spots where that operation doesn’t make sense for that data structure (for instance, you can’t index a stack, or pop from the end of a queue). We’ve provided the first few answers for you.

Fill in the runtimes for the following actions for the table below:

Data Structure  Index   Search  Add-R   Add-L   Pop-L   Pop-R
Python List (Array) O(1)    O(n)    O(1)    O(n)  O(n)  O(1)      
Linked List        O(n)   O(n)   O(1)    O(1)    O(1)    O(1)              
Doubly-Linked List  O(n)  O(n)   O(1)    O(1)    O(1)    O(1)                 
Queue (as Array)    X      X       X       X     O(n)    O(1)
Queue (as LL or DLL)    X   X       X       X    O(n)    O(1)
Stack (as Array, LL, or DLL)    X   X       X    X       O(1)
Deque (as DLL)  X   X       O(n)   O(1)   O(1)   O(1)    O(1)
Index: Find an item in the structure when you know its position
Search: Find an item in the structure when you know its data
Add(R/L): Set a key in set/dictionary or add node to tree
Pop(R/L): Remove a key or node


Fill in Runtime and Memory:

The answers for dictionary have been provided; you should fill in the rest:

Data Structure          Get      Add    Delete  Iterate Memory
Dictionary (Hash Map)   O(1)    O(1)    O(1)    O(n)    medium
Set (Hash Map)          O(n)    O(1)    O(1)    O(n)    medium         
Binary Search Tree      O(long n) O(log n) O(log n) O(n) small             
Tree                    O(n)    O(1)    O(1)    O(n)     small 
Get: Find an item in the structure
Add: Set a key in set/dictionary or add node to tree
Delete: Remove a key or node
Iterate: Find next item in data structure
Memory: Relative to data, how much memory is used? (Choices: a little, medium, or a lot)
Sorting

Describe in words how the Bubble Sort algorithm works.

Answer:
    The largest numbers bubble to the top. Taking pairs or numbers, we compair the first pair, if the first number is larger than the second number, we have them swap places. We continue doing this until the list is sorted. 

Describe in words how the Merge Sort algorithm works.

Answer:
    Merge sort breaks down a list into smaller and smaller pieces until each piece is a list of one item. We can do this ising recursion. The lists are then merged back together, two at a time. 


Describe in words how the Quick Sort algorithm works.

Answer:
    Quicksort uses a pivot which is a sometimes rendom number that we ask each of the other numbers in a list wheather they are larger or smaller than the pivot. We can do this recursivly until the list is sorted. 





